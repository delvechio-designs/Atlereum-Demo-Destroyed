import datetime

from django.shortcuts import render, redirect
from django.utils import timezone
from django.views.generic import View, CreateView
from django.db.models import Q, Sum
from django.db.models.functions import TruncMonth
from django.contrib.auth.mixins import LoginRequiredMixin
import calendar
from collections import defaultdict

from orders.forms import OfferForm
from pentests.models import Pentest
from earnings.models import Earning
from orders.models import Order

# Create your views here.


class HomeView(LoginRequiredMixin, View):
    def get(self, request):
        if request.user.is_business:
            return redirect("dashboard:BusinessHomeView")

        current_time = timezone.now()

        earnings = Earning.objects.filter(user=request.user)

        ongoing_orders = Order.objects.filter(
            Q(Q(buyer=self.request.user) | Q(seller=self.request.user)) &
            Q(is_completed=False) &
            Q(is_cancelled=False)
        )

        # Query to get earnings for each month
        earnings_by_month = earnings.filter(
            created_at__isnull=False,  # Ensure there's a created_at date
        ).annotate(
            month=TruncMonth('created_at')  # Extract the month from the created_at field
        ).values('month').annotate(
            total_earnings=Sum('amount')  # Calculate the total earnings for each month
        ).order_by('month')

        # Create a dictionary with default values for all months
        monthly_earnings = defaultdict(int)

        # Populate the dictionary with data from the queryset
        for entry in earnings_by_month:
            month = entry['month'].strftime('%b')  # Abbreviated month name (e.g., "Jan")
            total_earnings = entry['total_earnings']
            monthly_earnings[month] = total_earnings

        # Create a list of fixed labels for all months
        fixed_labels = [calendar.month_abbr[i] for i in range(1, 13)]

        # Create a list of total earnings corresponding to each month
        data = [monthly_earnings[month] for month in fixed_labels]

        # Create a dictionary in the format Chart.js expects
        earnings_chart_data = {
            'labels': fixed_labels,
            'data': data,
        }



        monthly_earnings = sum(
            earnings.filter(
                created_at__range=[
                    current_time - datetime.timedelta(days=30),
                    current_time,
                ]
            ).values_list("amount", flat=True)
        )

        yearly_earnings = sum(
            earnings.filter(
                created_at__range=[
                    current_time - datetime.timedelta(days=365),
                    current_time,
                ]
            ).values_list("amount", flat=True)
        )

        context = {
            "monthly_earnings": monthly_earnings,
            "yearly_earnings": yearly_earnings,
            "ongoing_orders": ongoing_orders,
            "earnings_chart_data": earnings_chart_data,
        }

        return render(request, "dashboard/home.html", context)


class BusinessHomeView(LoginRequiredMixin, View):
    def get(self, request):
        if request.user.is_pentester:
            return redirect("dashboard:HomeView")

        current_time = timezone.now()

        spendings = Earning.objects.filter(order__buyer=request.user)

        ongoing_orders = Order.objects.filter(
            Q(Q(buyer=self.request.user) | Q(seller=self.request.user)) &
            Q(is_completed=False) &
            Q(is_cancelled=False)
        )

        # Query to get earnings for each month
        spendings_by_month = spendings.filter(
            created_at__isnull=False,  # Ensure there's a created_at date
        ).annotate(
            month=TruncMonth('created_at')  # Extract the month from the created_at field
        ).values('month').annotate(
            total_earnings=Sum('amount')  # Calculate the total earnings for each month
        ).order_by('month')

        # Create a dictionary with default values for all months
        monthly_earnings = defaultdict(int)

        # Populate the dictionary with data from the queryset
        for entry in spendings_by_month:
            month = entry['month'].strftime('%b')  # Abbreviated month name (e.g., "Jan")
            total_earnings = entry['total_earnings']
            monthly_earnings[month] = total_earnings

        # Create a list of fixed labels for all months
        fixed_labels = [calendar.month_abbr[i] for i in range(1, 13)]

        # Create a list of total earnings corresponding to each month
        data = [monthly_earnings[month] for month in fixed_labels]

        # Create a dictionary in the format Chart.js expects
        spendings_chart_data = {
            'labels': fixed_labels,
            'data': data,
        }


        monthly_spendings = sum(
            spendings.filter(
                created_at__range=[
                    current_time - datetime.timedelta(days=30),
                    current_time,
                ]
            ).values_list("amount", flat=True)
        )

        yearly_spendings = sum(
            spendings.filter(
                created_at__range=[
                    current_time - datetime.timedelta(days=365),
                    current_time,
                ]
            ).values_list("amount", flat=True)
        )

        context = {
            "monthly_spendings": monthly_spendings,
            "yearly_spendings": yearly_spendings,
            "ongoing_orders": ongoing_orders,
            "spendings_chart_data": spendings_chart_data,
        }

        return render(request, "dashboard/home_business.html", context)


class FindWorkView(LoginRequiredMixin, View):
    def get(self, request):
        if request.user.role == 2:
            offer_form = OfferForm()
            pentests = Pentest.objects.all()
            pentest_type = self.request.GET.get("pentest_type")

            print(pentest_type)

            if pentest_type:
                pentests = pentests.filter(asset__type=pentest_type)

            context = {
                "pentests": pentests,
                "offer_form": offer_form,
            }
            return render(request, "dashboard/pentester_home.html", context)






# ===================For Proposal==================
import datetime
from django.shortcuts import render, redirect
from django.utils import timezone
from django.views.generic import View, CreateView
from django.contrib.auth.mixins import LoginRequiredMixin
from .models import Proposal
from .forms import ProposalForm
from .serializers import ProposalSerializer
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response

# ===================For Proposal==================

# List all proposals for a user
def proposal_list(request):
    # Fetch proposals associated with the logged-in user
    proposals = Proposal.objects.filter(user=request.user)
    return render(request, 'dashboard/proposals_list.html', {'proposals': proposals})

# Proposal creation view
class ProposalCreateView(LoginRequiredMixin, CreateView):
    model = Proposal
    form_class = ProposalForm
    template_name = 'dashboard/proposal_form.html'  # Template for creating a proposal
    success_url = '/dashboard/proposals/'  # Redirect to proposals list after successful creation

    def form_valid(self, form):
        # Automatically associate the proposal with the logged-in user
        form.instance.user = self.request.user  
        return super().form_valid(form)

# Retrieve, update, or delete a specific proposal
def proposal_detail(request, pk):
    try:
        proposal = Proposal.objects.get(pk=pk, user=request.user)  # Fetch proposal by ID
    except Proposal.DoesNotExist:
        return Response(status=status.HTTP_404_NOT_FOUND)

    if request.method == 'GET':
        serializer = ProposalSerializer(proposal)
        return Response(serializer.data)

    elif request.method == 'PUT':
        serializer = ProposalSerializer(proposal, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    elif request.method == 'DELETE':
        proposal.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)



# ===================For active fundinga activites For leander & investors ==========================
from django.shortcuts import render
from dashboard.models import FundingOpportunity
from django.core.paginator import Paginator
from .models import FundingOpportunity

from django.core.paginator import Paginator
from django.shortcuts import render
from .models import FundingOpportunity

from django.core.paginator import Paginator
from django.shortcuts import render

from django.core.paginator import Paginator
from django.shortcuts import render
from dashboard.models import FundingOpportunity

def active_funding_opportunities(request):
    # Get filter values from request
    search_query = request.GET.get('search', '').strip()
    status_filter = request.GET.get('status', '').strip()

    # Initialize the queryset with both open and closed opportunities
    opportunities = FundingOpportunity.objects.filter(status__in=['open', 'closed'])

    # Apply search filtering if there is a search query
    if search_query:
        opportunities = opportunities.filter(company_name__icontains=search_query)

    # Apply status filtering if a specific status is selected
    if status_filter in ['open', 'closed']:
        opportunities = opportunities.filter(status=status_filter)

    # Order the queryset by a specific field (e.g., 'created_at' or 'id')
    opportunities = opportunities.order_by('-created_at')  # You can change this to any relevant field

    # Pagination
    paginator = Paginator(opportunities, 9)  # Show 9 opportunities per page
    page_number = request.GET.get('page', 1)  # Default to the first page if none is specified
    opportunities_page = paginator.get_page(page_number)

    context = {
        'opportunities': opportunities_page,
        'current_page': opportunities_page.number,
        'total_pages': paginator.num_pages,
        'has_previous': opportunities_page.has_previous(),
        'has_next': opportunities_page.has_next(),
        'previous_page': opportunities_page.previous_page_number() if opportunities_page.has_previous() else None,
        'next_page': opportunities_page.next_page_number() if opportunities_page.has_next() else None,
        'search': search_query,
        'status': status_filter,
    }
    
    return render(request, 'dashboard/active_funding_opportunities.html', context)











# views.py
from django.shortcuts import render, redirect, get_object_or_404
from .models import FundingOpportunity

def opportunity_detail(request, id):
    opportunity = get_object_or_404(FundingOpportunity, id=id)

    # Fetch related opportunities by category, excluding the current opportunity
    related_opportunities = FundingOpportunity.objects.filter(
        category=opportunity.category
    ).exclude(id=opportunity.id)

    # Check if the opportunity is open
    is_open = opportunity.status == 'open'

    context = {
        'opportunity': opportunity,
        'related_opportunities': related_opportunities,
        'is_open': is_open,
    }

    return render(request, 'dashboard/opportunity_detail.html', context)







# ================Save Operunity ======================
# views.py
from django.shortcuts import render, redirect, get_object_or_404
from .models import FundingOpportunity, SavedOpportunity
from django.contrib import messages

def save_opportunity(request, id):
    opportunity = get_object_or_404(FundingOpportunity, id=id)
    saved_opportunity, created = SavedOpportunity.objects.get_or_create(
        user=request.user,
        funding_opportunity=opportunity
    )
    if created:
        messages.success(request, "Opportunity saved!")
    else:
        messages.info(request, "Opportunity already saved.")
    return redirect('dashboard:opportunity_detail', id=id)   # Redirect to the opportunity detail page

def saved_opportunities(request):
    saved_opps = SavedOpportunity.objects.filter(user=request.user).select_related('funding_opportunity')
    context = {
        'saved_opportunities': saved_opps
    }
    return render(request, 'dashboard/saved_opportunities.html', context)



# ========== Saved Opportunity ============










# from .models import Opportunity 
# from django.http import JsonResponse
# def save_notes(request, id):
#     if request.method == 'POST':
#         note = request.POST.get('note')  # Get note from the form
#         opportunity = Opportunity.objects.get(id=id)
#         opportunity.notes.create(content=note)  # Save the note related to the opportunity
#         return JsonResponse({'success': True})
#     return JsonResponse({'success': False}, status=400)





