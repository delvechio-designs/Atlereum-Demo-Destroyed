# Import statements
from django.shortcuts import render, redirect,get_object_or_404
from django.urls import reverse_lazy, reverse
from django.contrib import messages
from django.views.generic import View
from .forms import UserRegisterForm, UserUpdateForm, PentestProfileForm
from .models import User # Adjust import according to your model location 
from django.contrib.auth import logout
from django.contrib.auth.views import LoginView as auth_views_LoginView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.utils.crypto import get_random_string
from django.utils import timezone
from datetime import timedelta
from django.contrib.auth.tokens import default_token_generator
from django.utils.encoding import force_str
from django.utils.http import urlsafe_base64_encode, urlsafe_base64_decode
from django.contrib.sites.shortcuts import get_current_site
from django.conf import settings
from .forms import UserRegisterForm  # Ensure this import is correct
from django.contrib.auth import views as auth_views
from django.contrib.auth import logout as auth_logout
from django.core.mail import send_mail
from django.utils.html import strip_tags
from django.template.loader import render_to_string
from django.http import JsonResponse
import logging
from django.utils.http import urlencode
from .utils import generate_new_verification_code, send_verification_email # Assuming you have this function
from django.contrib.auth import get_user_model  # Use this to get the User model
from django.utils.timezone import now
import random
import string
logger = logging.getLogger(__name__)
from django.contrib.auth.models import Group  # To check the user's group/role
# Import in your views.py
from authentication.models import Pentest
from pentests.models import Pentest
from django.views.generic import UpdateView
from common.stripe import create_charge_for_business_activation

import re





# ================== User ROle base Home Section start==========================

# Home View - Redirects to the appropriate dashboard based on user role if authenticated, otherwise renders the home page.
class HomeView(View):
    def get(self, request):
        if request.user.is_authenticated:
            if request.user.is_business:
                return redirect('users:BusinessDashboardView')
            elif request.user.is_pentester:
                return redirect('users:PentesterDashboardView')
        return render(request, "home.html")
    
# Profile Views
class ProfileView(LoginRequiredMixin, View):
    def get(self, request):
        if request.user.is_business:
            return redirect('users:BusinessProfileView')
        elif request.user.is_pentester:
            return redirect('users:PentestProfileView')
        return redirect('users:HomeView')
    
# Login View - Redirects to the appropriate dashboard based on user role after login.
class LoginView(auth_views_LoginView):
    template_name = 'dashboard/login.html'

    def get_success_url(self):
        user = self.request.user
        if user.is_business:
            return reverse('users:BusinessDashboardView')
        elif user.is_pentester:
            return reverse('users:PentesterDashboardView')
        return reverse('users:HomeView')
# ================== User ROle base Home Section end ==========================






# =================== Authentication User Section start ==========================

# =============RegisterViews============
class RegisterView(View):
    def get(self, request):
        form = UserRegisterForm()
        return render(request, 'dashboard/register.html', {'form': form})

    def post(self, request):
        form = UserRegisterForm(request.POST, request.FILES)
        if form.is_valid():
            user = form.save(commit=False)
            user.is_verified = False
            user.save()

            user_role = form.cleaned_data.get('role')  # Make sure this field is valid
            print(f'User role assigned: {user_role}')  # Debug output

            verification_code = random.randint(1000, 9999)
            request.session['verification_code'] = verification_code
            request.session['verification_email'] = user.email
        
            send_mail(
                'Email Verification',
                f'Your verification code is {verification_code}.',
                settings.DEFAULT_FROM_EMAIL,
                [user.email],
                fail_silently=False,
            )

            messages.success(request, 'A verification code has been sent. Please verify your email.')

            # Redirect based on user role
            if user_role == 'Business':
                return redirect('users:BusinessDashboardView')
            elif user_role == 'Pentrest':
                return redirect('users:PentesterDashboardView')

            return redirect('users:verify_email')  # Fallback if role doesn't match

        # Print form errors for debugging
        print(form.errors)
        return render(request, 'dashboard/register.html', {'form': form})







# ======================= VerifyEmailView ===============
class VerifyEmailView(View):
    def get(self, request):
        return render(request, 'dashboard/verify_email.html')

    def post(self, request):
        code = request.POST.get('verification_code')
        if code == str(request.session.get('verification_code')):
            email = request.session.get('verification_email')
            users = User.objects.filter(email=email)  # Use filter to get a queryset
            if users.exists():
                if users.count() == 1:
                    user = users.first()  # Get the single user
                    user.is_verified = True
                    user.save()
                    messages.success(request, 'Your email has been verified! You can now log in.')
                    return redirect('users:LoginView')
                else:
                    messages.error(request, 'Multiple users found with the same email address.')
                    return render(request, 'dashboard/verify_email.html')
            else:
                messages.error(request, 'No user found with that email address.')
                return render(request, 'dashboard/verify_email.html')
        else:
            messages.error(request, 'Invalid verification code.')
            return render(request, 'dashboard/verify_email.html')

    
# ================ logout_views===

def logout_view(request):
    logout(request)
    messages.success(request, 'You have been logged out.')
    return redirect('users:logout-page')  # Redirect to the logout page


# ===========Logout Page Views =========
class LogoutPageView(View):
    def get(self, request):
        return render(request, 'dashboard/logout.html')

# ======= Forget Password Section start =====================
class ForgotPasswordView(View):
    def get(self, request):
        return render(request, 'dashboard/forgot-password.html')

    def post(self, request):
        email = request.POST.get('email')
        if not User.objects.filter(email=email).exists():
            messages.error(request, 'No user found with that email.')
            return render(request, 'dashboard/forgot-password.html')
        
        user = User.objects.get(email=email)
        reset_code = random.randint(1000, 9999)
        request.session['reset_code'] = reset_code
        request.session['reset_email'] = email
        
        # Send reset code email
        send_mail(
            'Password Reset Code',
            f'Your password reset code is {reset_code}.',
            settings.DEFAULT_FROM_EMAIL,
            [email],
            fail_silently=False,
        )

        messages.success(request, 'A password reset code has been sent to your email.')
        return redirect('users:reset_password')



# ============= ResetPassword ============
class ResetPasswordView(View):
    def get(self, request):
        return render(request, 'dashboard/reset_password.html')

    def post(self, request):
        code = request.POST.get('reset_code')
        if code == str(request.session.get('reset_code')):
            email = request.session.get('reset_email')
            return redirect('users:confirm_reset_password')  # Redirect to confirm password reset
        else:
            messages.error(request, 'Invalid reset code.')
            return render(request, 'dashboard/reset_password.html')


# ================ConfirmResetPassword ==========
class ConfirmResetPasswordView(View):
    def get(self, request):
        return render(request, 'dashboard/confirm_reset_password.html')

    def post(self, request):
        password = request.POST.get('password')
        password_confirm = request.POST.get('password_confirm')

        # Password strength validation
        if not self.is_strong_password(password):
            messages.error(request, 'Password must be at least 8 characters long and include a mix of letters, numbers, and symbols.')
            return render(request, 'dashboard/confirm_reset_password.html')

        if password != password_confirm:
            messages.error(request, 'Passwords do not match.')
            return render(request, 'dashboard/confirm_reset_password.html')

        email = request.session.get('reset_email')
        user = User.objects.get(email=email)
        user.set_password(password)
        user.save()

        messages.success(request, 'Your password has been reset successfully. You can now log in.')
        return redirect('users:LoginView')

    def is_strong_password(self, password):
        # Check password strength
        if (len(password) < 8 or
                not re.search(r'[A-Z]', password) or  # At least one uppercase letter
                not re.search(r'[a-z]', password) or  # At least one lowercase letter
                not re.search(r'[0-9]', password) or  # At least one digit
                not re.search(r'[@$!%*?&]', password)):  # At least one special character
            return False
        return True


# Login View - Redirects to the appropriate dashboard based on user role after login.
class LoginView(auth_views_LoginView):
    template_name = 'dashboard/login.html'

    def get_success_url(self):
        user = self.request.user
        if user.is_business:
            return reverse('users:BusinessDashboardView')
        elif user.is_pentester:
            return reverse('users:PentesterDashboardView')
        return reverse('users:HomeView')

    
# Logout Views - Redirect to Logout template
def logout_view(request):
    logout(request)
    messages.success(request, 'You have been logged out.')
    return redirect('users:logout-page')  # Redirect to the logout page

# Logout Page Views
class LogoutPageView(View):
    def get(self, request):
        return render(request, 'dashboard/logout.html')

# =================== Authentication User Section End==========================






# =================== AuthProfile Views   Section start==========================


# Profile View for Business Users - Displays and updates the user's profile information.
class BusinessProfileView(LoginRequiredMixin, View):
    def get(self, request):
        form = UserUpdateForm(instance=request.user)
        return render(request, 'dashboard/profile.html', {'form': form})

    def post(self, request):
        form = UserUpdateForm(request.POST, request.FILES, instance=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, 'Your account has been updated!')
            return redirect('users:BusinessProfileView')
        else:
        # Log the errors to the console
            print(form.errors)  # Add this line for debugging
        return render(request, 'dashboard/profile.html', {'form': form})


    

# Profile View for Pentest Users - Displays and updates the user's profile information.
class PentestProfileView(UpdateView):
    model = Pentest
    form_class = PentestProfileForm
    template_name = 'dashboard/pentrest_profile.html'

    def get_object(self, queryset=None):
        # Use get_object_or_404 to raise a 404 error if the object does not exist
        pentest, created = Pentest.objects.get_or_create(user=self.request.user)
        return pentest

    def get_success_url(self):
        # Return the success URL with the pk of the updated object
        return reverse_lazy('pentests:pentest_profile', kwargs={'pk': self.object.pk})

    def form_valid(self, form):
        form.save()  # Save the form directly without passing user
        messages.success(self.request, "Your profile has been updated successfully.")
        return super().form_valid(form)

    def form_invalid(self, form):
        messages.error(self.request, "Please correct the errors below.")
        return super().form_invalid(form)


# =================== AuthProfile Views Section end==========================

def profile_view(request):
    if request.user.is_authenticated:
        pentests = Pentest.objects.filter(user=request.user)  # Ensure this line is correct
        return render(request, 'profile.html', {'pentests': pentests})
    return redirect('login')

# =================== DashboardboardViwes ==========================

# BusinessDashboardView 
class BusinessDashboardView(LoginRequiredMixin, View):
    def get(self, request):
        return render(request, 'dashboard/home_business.html')
    
# PentesterDashboardView
class PentesterDashboardView(LoginRequiredMixin, View):
    def get(self, request):
        return render(request, 'dashboard/pentester_home.html')
# =================== DashboardboardViwes ==========================











 

# Activate business view
class ActivateBusinessView(LoginRequiredMixin, View):
    def get(self, request):
        return render(request, 'dashboard/business-packages.html')

    def post(self, request):
        package_type = request.POST.get("type")
        session_url = create_charge_for_business_activation(request.user.id, package_type)
        return redirect(session_url)

# Payment success view
class PaymentSuccessView(View):
    def get(self, request):
        return render(request, 'dashboard/payment_success.html')

# Payment cancel view
class PaymentCancelView(LoginRequiredMixin, View):
    def get(self, request):
        return render(request, 'dashboard/cancel.html')

# services page
def services(request):
    return render(request, 'services.html')

# contactus 


# contactus view
from django.core.mail import send_mail
from django.conf import settings
from django.shortcuts import render, redirect
from django.contrib import messages
import time
import re

# List of common disposable email domains
DISPOSABLE_DOMAINS = ["mailinator.com", "tempmail.com", "10minutemail.com", "guerrillamail.com"]

# Define a constant time period (in seconds) during which the same email can't submit again
SUBMISSION_LIMIT_SECONDS = 60 * 5  # 5 minutes

# Function to check if email is from a disposable domain
def is_temporary_email(email):
    domain = email.split('@')[-1]
    return domain in DISPOSABLE_DOMAINS

# Function to validate email format (simple regex validation)
def is_valid_email(email):
    email_regex = r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"
    return re.match(email_regex, email)

# contactus view
def contactus(request):
    if request.method == 'POST':
        # Get form data
        name = request.POST.get('name')
        email = request.POST.get('email')
        phone = request.POST.get('phone', '')  # Phone is optional
        message = request.POST.get('message')

        # 1. Check if the email is valid
        if not is_valid_email(email):
            messages.error(request, 'Please provide a valid email address.')
            return redirect('/contact/')

        # 2. Check if the email is a temporary/disposable email
        if is_temporary_email(email):
            messages.error(request, 'Please use a non-disposable email address.')
            return redirect('/contact/')

        # 3. Prevent multiple submissions from the same email within a defined period
        last_submission = request.session.get('last_submission_time', {}).get(email, 0)
        current_time = time.time()

        if current_time - last_submission < SUBMISSION_LIMIT_SECONDS:
            messages.error(request, 'You have already submitted a message. Please wait a few minutes before submitting again.')
            return redirect('/contact/')

        # Compose email message to send to admin
        subject = f"New Contact Form Submission from {name}"
        message_body = f"Name: {name}\nEmail: {email}\nPhone: {phone}\n\nMessage:\n{message}"
        admin_email = settings.DEFAULT_CONTACT_EMAIL  # Admin email set in settings.py

        # Send email
        try:
            send_mail(subject, message_body, settings.EMAIL_HOST_USER, [admin_email], fail_silently=False)

            # Save the current submission time to session
            if 'last_submission_time' not in request.session:
                request.session['last_submission_time'] = {}
            request.session['last_submission_time'][email] = current_time

            # Display success message
            messages.success(request, 'Your message has been sent successfully!')
        except Exception as e:
            # Handle errors if email sending fails
            messages.error(request, 'There was an error sending your message. Please try again later.')

        return redirect('/contact/')  # Redirect after form submission

    return render(request, 'contact_us.html')

