# notifications/views.py
from rest_framework import viewsets, status
from rest_framework.response import Response
from .models import Notification
from .serializers import NotificationSerializer
from .signals import send_notification
from django.shortcuts import get_object_or_404
from django.conf import settings
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from datetime import timedelta
from django.utils import timezone
from notifications.models import Message




class NotificationViewSet(viewsets.ModelViewSet):
    queryset = Notification.objects.all()
    serializer_class = NotificationSerializer

    def create(self, request, *args, **kwargs):
        notification_type = request.data.get('type')
        user_id = request.data.get('user_id')
        user = get_object_or_404(settings.AUTH_USER_MODEL, id=user_id)

        title, description = self._get_notification_details(notification_type)

        # Check if the notification already exists for this user and type
        existing_notification = Notification.objects.filter(
            user=user,
            title=title,
            description=description,
            created_at__gte=timezone.now() - timedelta(hours=24)  # Check within the last 24 hours
        ).first()

        if existing_notification:
            return Response({"detail": "Notification already exists."}, status=status.HTTP_400_BAD_REQUEST)

        notification = Notification.objects.create(
            user=user,
            title=title,
            description=description
        )
        print(f"Created notification: {notification.title}, sending to clients.")

        # Send notification to the WebSocket
        self.send_notification_to_clients({
            'title': notification.title,
            'description': notification.description,
            'created_at': notification.created_at.strftime("%Y-%m-%d %H:%M:%S"),
        })

        serializer = self.get_serializer(notification)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    def destroy(self, request, *args, **kwargs):
        # Custom delete logic for expired notifications
        Notification.objects.filter(expire_at__lt=timezone.now()).delete()  # Delete expired notifications
        return Response(status=204)  # Return no content

    def _get_notification_details(self, notification_type):
        if notification_type == "approval":
            return "Approval Notification", "Your request has been approved."
        elif notification_type == "rejection":
            return "Rejection Notification", "Your request has been rejected."
        elif notification_type == "admin":
            return "Admin Notification", "Admin update description."
        elif notification_type == "proposal":
            return "Proposal Notification", "Your proposal status has been updated."
        elif notification_type == "order":
            return "Order Notification", "Your order status has been updated."
        return "New Notification", ""
    
    def _get_notification_details(self, notification_type):
        # Example function to retrieve notification details based on type
        if notification_type == "application":
            return "Application Notification", "You have received a new application."
        return "New Notification", ""








# 
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from django.contrib.auth import get_user_model
from notifications.models import Message
from django.http import JsonResponse

User = get_user_model()

@login_required
def send_message(request):
    if request.method == 'POST':
        sender = request.user
        receiver_id = request.POST.get('receiver_id')
        content = request.POST.get('content')

        if not receiver_id or not content:
            return JsonResponse({"error": "Receiver and content are required"}, status=400)

        try:
            # Fetch the receiver user
            receiver = User.objects.get(id=receiver_id)

            # Save the message to the Message model
            message = Message.objects.create(
                sender=sender,
                receiver=receiver,
                content=content
            )

            # Send message notification (using WebSockets or real-time notification system)
            send_message_notification(receiver, message)

            return JsonResponse({"message": "Message sent and notification triggered"}, status=201)

        except User.DoesNotExist:
            return JsonResponse({"error": "Receiver does not exist"}, status=404)

    return JsonResponse({"error": "Invalid request method"}, status=405)

def send_message_notification(receiver, message):
    # This function will trigger the message notification, using WebSockets or any real-time method
    notification_data = {
        "title": f"New message from {message.sender.username}",
        "content": message.content,
        "timestamp": message.created_at.strftime("%Y-%m-%d %H:%M:%S")
    }

    # If you're using WebSockets, emit the notification to the receiver
    # You could implement this using Django Channels, Socket.IO, etc.
    # Example with Django Channels:
    # channel_layer = get_channel_layer()
    # async_to_sync(channel_layer.group_send)(
    #     f"user_{receiver.id}",
    #     {
    #         "type": "message_notification",
    #         "message": notification_data,
    #     }
    # )

    print(f"Sending notification to {receiver.username}: {notification_data}")

