import json
from channels.generic.websocket import AsyncWebsocketConsumer

class VideoConsumer(AsyncWebsocketConsumer):
    guests_count = 0  # Keep track of guest users

    async def connect(self):
        self.room_group_name = "video_chat_room"

        # Add the connection to the group
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()

        # Check if the user is authenticated (logged in)
        if self.scope["user"].is_authenticated:
            # If user is authenticated, they are the host
            username = self.scope["user"].username
            role = "Host"
        else:
            # If user is not logged in, they are a guest
            VideoConsumer.guests_count += 1
            username = f"Guest {VideoConsumer.guests_count}"  # Assign unique Guest ID
            role = "Guest"

        # Store the user's role in their session
        self.username = username
        self.role = role

        # Broadcast a message that a new user has joined
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'user_join',
                'message': f'{username} ({role}) has joined the meeting!',
                'user_id': username,
                'role': role
            }
        )

    async def disconnect(self, close_code):
        # Remove the connection from the group
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )

        # Broadcast a message that the user has left
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'user_leave',
                'message': f'{self.username} ({self.role}) has left the meeting!'
            }
        )

    async def receive(self, text_data):
        data = json.loads(text_data)

        message_type = data.get('type', None)
        if not message_type:
            await self.send(text_data=json.dumps({
                'message': 'Unrecognized message type'
            }))
            return

        # Handle signaling messages based on type
        if message_type in ['offer', 'answer', 'ice_candidate']:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'webrtc_signal',
                    'message': data
                }
            )
        elif message_type == 'chat':
            # Handle chat messages
            chat_message = data.get('message', '')
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'chat_message',
                    'message': chat_message,
                    'sender': self.username
                }
            )
        else:
            # Handle other unrecognized message types
            await self.send(text_data=json.dumps({
                'message': 'Unrecognized message type'
            }))

    # Handler to send signaling messages to WebSocket clients
    async def webrtc_signal(self, event):
        message = event['message']
        print(f"Sending signaling message: {message}")  # Log signaling messages
        await self.send(text_data=json.dumps(message))


    # Handler for chat messages
    async def chat_message(self, event):
        message = event['message']
        sender = event['sender']
        
        # Send the chat message to WebSocket clients
        await self.send(text_data=json.dumps({
            'type': 'chat',
            'message': message,
            'sender': sender
        }))

    # Handler for user join event
    async def user_join(self, event):
        message = event['message']
        user_id = event['user_id']
        role = event['role']
        
        # Send join notification to all clients
        await self.send(text_data=json.dumps({
            'type': 'join',
            'message': message,
            'user_id': user_id,
            'role': role
        }))

    # Handler for user leave event
    async def user_leave(self, event):
        message = event['message']
        
        # Send leave notification to all clients
        await self.send(text_data=json.dumps({
            'type': 'leave',
            'message': message
        }))
